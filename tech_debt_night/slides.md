
<!-- template: invert -->

# RDBに関する技術的負債とその重さ

#### @joker1007

---


# self.inspect
- @joker1007
- Repro inc. CTO (要は色々やる人)
  - Ruby/Rails
  - fluentd/embulk
  - Docker/ECS
  - Bigquery/EMR/Hive/Presto

最近、クレカで50万円近く不正利用されたことが発覚しクソ辛い

---

# ここ最近はマジで負債返済業ばかり

---

# この話での技術的負債とは
システム開発における生産性を阻害する要素全般。
その中でも特にコードとRDBにおける以下の様な要素。
- 読むのが辛い / 読むのに時間がかかる
- 修正するのが辛い / 危ない / 時間がかかる
- 処理が重い / 仕組み上スケールできない

---

# この話での技術的負債とは 2
技術的負債は、その原因にいくつか種類がある。
- 単純に開発技術に関する無知や未熟さによるもの
- ビジネス上の不可避の変更により邪魔になったもの
- 意識的な手抜き(主に時間的なプレッシャーによる)
- 無意識の手抜き(同上)

この中でも一番厄介なのは無知/未熟さによるものや無意識の手抜きであり、この話では主にそれについて扱う。
ナイーブな技術的負債とも呼ばれる。

---

# 何故ナイーブな負債が厄介か
- 書いた本人が気付いていないことが多い
  - 結果、発見が遅れる
- 開発初期の開発プロセスやメンバーが未熟な時期に多く発生する
  - その上に様々な機能が構築されるため、大量の機能から参照されている可能性が高い
- アーキテクチャが適切でないことが多いため、バグを生み易くパフォーマンス上の破綻も早くやってくる
- 「大体直すのは別の人」なので、経緯を把握するのに手間がかかる 

---

# ナイーブな技術的負債の発見
ほとんどの場合、新しい機能開発をする際のコードリーディング時に偶然発見される。

ただし、ただ読むだけでは発見できないこともある。

---

## 大事なのは既存の実装を常に疑ってかかること
## 過去の自分も含めて誰も信用するな

---

## そんなに複雑な訳がない
## という前提でコードと向き合う
#### つまり、今よりマシな状態に改善できるはず、という思いを持ってコードを読む

---

# 俺の基準
1. 集中してコードを読んで、1分以上かかっても何やってんのか良く分からんメソッドがある場合、その処理は何かおかしいという可能性を踏まえてコードを読む。
1. 一連の処理のコードを読んだりしている最中に行ったり来たりが繰り返される場合、クラス間の依存関係がおかしいという可能性を踏まえてコードを読む。
1. 複数のActiveRecordモデルを何度も必要とする様な処理があった場合、RDBのデータの持ち方やクエリの仕方がおかしいという可能性を踏まえてコードを読む。
1. ActiveRecordのserializeを使ってYAMLを格納している場合 -> 問答無用で殺す
1. ポリモーフィック関連のクラス名を文字列にしてcase文を書いている場合 -> 問答無用で殺す

---

## 意識を強く保たないと、人は容易に割れ窓に割れ窓を重ねていく
## 自分のストレスや怒りを見逃すな
## 忖度するな、直接聞け

---

# 対象レイヤーと厄介レベル

### level1:
仕様そのものに起因する問題 (交渉が成功すれば機能ごと削除できる)


### level2:
コード上の構造に起因する問題

### level3:
永続的なデータの構造に起因する問題

---

# 一番理想的なのは機能ごと捨てること
# コードが無い状態が最も安全であり最強
# そしてRDBのレイヤーまで問題が降りてくると死ねる
# ほぼ全ての機能はRDBのデータに依存しているので
# RDBが辛い = ほぼ全てが辛い


---

# しかし、往々にして
# Web系のスタートアップには
# 稀じゃない程度によくある

---

# ここから具体例
# RDBのcolumn設計がおかしい例
###### というか苦労話w

---

## あるテーブル群のcolumnの問題点
- 集計結果を格納するテーブル群がある
- 何故かカラムの値が即値ではない。
- 日付と集計単位を表すテーブルとJOINしないと集計の軸が分からない
- BOOLEANの値も何故か別テーブルにある
- 環境毎にIDが異なるため本当に引くまで分からない
- インデックスで単純にソートできない
- レコード量は数百万件オーダー * 8

---

# 簡易化するとこういう感じ

## table A

|name   |type   |
|-------|-------|
|term_id|integer|
|count  |integer|

## table B
| name     | type    |
| -------  | ------- |
| id       | integer |
| unit     | varchar |
| start_on | date    |

こうであることに特に妥当な理由はないし、過去にもない。

---

# 直面した問題
- バッチ処理の負荷が肥大化、スケール上の問題が発生する
- テーブル構造上、同一の仕組みでは日付より細かい粒度に対応できない
- 単純にデータのメンテが辛い
- 日付を確定するだけでテーブルアクセスが必要
  - 本来不要なコードを量産する

---

# 直すのにかかっている時間
- 期間だけで言うと、関係する箇所に着手し始めて1年経つけどまだ半分残ってる。
- 実際に直接その問題に対して作業していた期間だけでも3ヶ月はかかっている。

---

## 直すための工程
1. 問題のカラム構造を使わないデータ転送及びバッチ処理ラインを全て再設計し実装する
1. 問題のカラム構造を使わないデータを集計してから、既存のtermテーブルその他とジョインしてIDを埋めるバッチを構築する
1. 並行運用して二種類集計しDBに格納する
1. 過去分のデータを再集計するためのデータ転送、バッチの再実行を行う (ちょっとづつ進める)
1. この時点でやっと関係するコードの変更をリリースできる様になる

---

## コードの規模感
- 関係するコードの修正は、数百のファイルに渡って4000行程の変更をし、まだ半分程のテーブルの依存が残っている。
- ちなみに、その過程で2000行程コードを削減することに成功した。

![pullreq1.jpg](pullreq1.jpg)
![pullreq2.jpg](pullreq2.jpg)
![pullreq3.jpg](pullreq3.jpg)

---

# 修正に必要だった知識
- Ruby/Railsをより読み易く整理できること
- vue.jsのコードが読めて修正できること
- fluentdのconfigと動作/運用に関する知識
- embulkのconfigと動作/運用に関する知識
- Bigqueryのクエリ設計に関する知識
- 複数のクエリを繋げてバッチワークフローを設計できること
- Hive/Prestoを用いたデータ変換とクエリ構築に関する知識
- RDBのデータマイグレーションのためのSQL構築

---

# とにかくRDBに関わる負債の解消は広範な知識と根気が必要
# しかも、時と共にどんどん増えていく
###### 自己紹介で書いた業務領域のほぼ全てをフル活用した

---

# つまりRDBの構造や設計には常に細心の注意を払うことが重要
###### (RDBに限らず永続的に保持するデータの構造には)

---

## 具体例2 (時間があれば)
## コードの設計が悪いものとの複合

---

# プッシュ通知配信スケジュール管理のコードが酷い
- 謎のサービスクラス
  - コード量こそ多くは無いが分岐がひどい
- ギリギリ感のある状態管理
- 実行状態の管理、実行履歴、キューイング、スケジューリングの4つの責務が混じったクラス

---

# こんな感じのコード(会場限定)

---

# とりあえず責任を分解する
- キューイング/スケジューリングを別のクラスに分解
- スケジューリングにsidekiqの時刻指定を利用する
  - ここで判断に失敗した

---

# sidekiqを利用したことによる問題
- 任意のタイミングでキャンセルが発生する
  - キャンセル様のジョブIDのハンドリングが煩雑
- 重複して配信要求があった場合古いものをキャンセルする
  - RDBのユニーク制約とロックでRDBレイヤーで保護
  - Redisと連携するためのキューイングのタイミングが結局難しい。
  - 繰り返しのスケジュールがあるため、結局再エンキューのためのスケジューラーデーモンが必要になる

一方で、責任の分離と自然なモデルメソッドになったことで、テストは書き易くなり充実した。

---

# 最終的な改善策
その他にも似た要件が増えたため、スケジューリング処理を汎用化したライブラリを開発した。
[joker1007/crono_trigger](https://github.com/joker1007/crono_trigger)

- 任意のActiveRecordモデルをスケジュール定義として利用できるジョブスケジューラ
- 単発のスケジュールとcronフォーマットをベースにした繰り返しのスケジュールに対応
- RDB上のデータを元に直接スケジュールするので、キャンセルや停止等の状態管理が楽
- 暗黙的な処理は出来るだけしない。

---

# crono_trigger導入後
- キューイングとスケジューリングの責務を更に分割。キューイングは今まで同様sidekiqに任せる。
- 700行程のコードの削減に成功
- スケジューリング処理は完全に独立した環境でテスト可能に
- その他の領域にも適用可能なので、今後更に数百行のコードを削減できる見込み

---

# まとめ
- RDBは一度しくじると、立て直しにとんでもなくコストがかかる
- そもそも記録していないデータは回収不可能
  - データライフサイクルの定義が無ければお手上げ
- 修正にかかる時には、とにかく幅広い範囲の知識が要る
  - 少なくとも多少複雑なSQLが書けて、INDEXやトランザクションに対してそれなりの知識が必要
- 最強は仕様から削り落として抹殺することなので、サービスの価値と仕様そのものとしっかり向かい合うこと
  - コードだろうが仕様だろうが既存のものが正しいなどということはない。疑え，全てを！

---

# RDBの設計は今後のサービスの発展全てを左右する。
# もし自信が無いなら、サービスの初期の段階で外部からでもいいからレビュアーを探して依頼するべき。
